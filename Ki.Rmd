---
title: "Ki"
author: "Ki Hyun"
date: "10/12/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(3736)
```

```{r packages, include=FALSE}
library(MASS)
library(tidyverse)
library(mgcv)
```

```{r data}
train <- read.csv("data-train.csv")
train.t <- read.csv("data-train.csv") %>% 
    mutate(
        Re = log(Re),
        Fr = 1 - exp(-Fr),
        St = log(St)
    )
```

Mutation on the Froude number was made so that the domain of $[0, \infty)$ for 
the variable could now be $[0, 1]$.
Log transformation was done on the Stokes number to reduce the skewness present
in the data. Moreover, Reynolds number also underwent log transformation in 
order for the scale of the predictors to be similar.

```{r box_cox_moment_1}
model.1 <- lm(R_moment_1 ~ St + Re + Fr, data = train.t)

bc.1 <- boxcox(R_moment_1 ~ St + Re + Fr, data = train.t)
lambda.1 <- bc.1$x[which.max(bc.1$y)]
```

```{r box_cox_moment_2}
model.2 <- lm(R_moment_2 ~ St + Re + Fr, data = train.t)

bc.2 <- boxcox(R_moment_2 ~ St + Re + Fr, data = train.t)
lambda.2 <- bc.2$x[which.max(bc.2$y)]
```

```{r box_cox_moment_3}
model.3 <- lm(R_moment_3 ~ St + Re + Fr, data = train.t)

bc.3 <- boxcox(R_moment_3 ~ St + Re + Fr, data = train.t)

lambda.3 <- bc.3$x[which.max(bc.3$y)]
```

```{r box_cox_moment_4}
model.4 <- lm(R_moment_4 ~ St + Re + Fr, data = train.t)

bc.4 <- boxcox(R_moment_4 ~ St + Re + Fr, data = train.t)

lambda.4 <- bc.4$x[which.max(bc.4$y)]
```

Compared to the first moment, the second, third, and fourth had significantly 
large values. Moreover, the distribution of these response variables appear to 
be extremely skewed. Therefore, box cox transformation was needed on the three 
moments for analysis. 

## First Moment

```{r First_Moment_setup}
shuffled_train <- train[sample(nrow(train)),]
folds <- cut(seq(1,nrow(train)),breaks=10,labels=FALSE)
lambda <- lambda.1

# error
rmse.cv.lm <- rep(0, 10)
```

#### No interaction term

```{r first_no_inter}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_1 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.0 <- mean(rmse.cv.lm)
```

#### St:Re

```{r first_inter_1}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_1 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(St):log(Re), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.1 <- mean(rmse.cv.lm)
```

#### St:Fr

```{r first_inter_2}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_1 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(St):I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.2 <- mean(rmse.cv.lm)
```

#### Re:Fr

```{r first_inter_3}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_1 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.3 <- mean(rmse.cv.lm)
```

#### Re:Fr and St:Re

```{r first_inter_4}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_1 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)) + log(Re):log(St), 
                data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.4 <- mean(rmse.cv.lm)
```

#### Re:Fr and St:Fr

```{r first_inter_5}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_1 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)) + 
                    I(1 - exp(-Fr)):log(St), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.5 <- mean(rmse.cv.lm)
```

#### St:Re and St:Fr

```{r first_inter_6}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_1 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):log(St) + 
                    I(1 - exp(-Fr)):log(St), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.6 <- mean(rmse.cv.lm)
```

#### All three

```{r first_inter_7}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_1 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):log(St) + 
                    I(1 - exp(-Fr)):log(St) + log(Re):I(1 - exp(-Fr)), 
                data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.7 <- mean(rmse.cv.lm)
```

```{r first_save}
CV_errors.lm  <- tibble(Model.0 = cv.0, Model.1 = cv.1, Model.2 = cv.2, 
                     Model.3 = cv.3, Model.4 = cv.4, Model.5 = cv.5, 
                     Model.6 = cv.6, Model.7 = cv.7)
```

For predicting the fourth moment, the model with the interaction term Re:Fr 
seems to have the lowest estimated test MSE according to the 10-fold cross 
validation process.

## Second Moment

```{r Second_Moment_setup}
lambda <- lambda.2
```

#### No interaction term

```{r second_no_inter}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_2 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.0 <- mean(rmse.cv.lm)
```

#### St:Re

```{r second_inter_1}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_2 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(St):log(Re), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.1 <- mean(rmse.cv.lm)
```

#### St:Fr

```{r second_inter_2}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_2 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(St):I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.2 <- mean(rmse.cv.lm)
```

#### Re:Fr

```{r second_inter_3}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_2 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.3 <- mean(rmse.cv.lm)
```

#### Re:Fr and St:Re

```{r second_inter_4}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_2 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)) + log(Re):log(St), 
                data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.4 <- mean(rmse.cv.lm)
```

#### Re:Fr and St:Fr

```{r second_inter_5}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_2 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)) + 
                    I(1 - exp(-Fr)):log(St), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.5 <- mean(rmse.cv.lm)
```

#### St:Re and St:Fr

```{r second_inter_6}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_2 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):log(St) + 
                    I(1 - exp(-Fr)):log(St), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.6 <- mean(rmse.cv.lm)
```

#### All three

```{r second_inter_7}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_2 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):log(St) + 
                    I(1 - exp(-Fr)):log(St) + log(Re):I(1 - exp(-Fr)), 
                data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.7 <- mean(rmse.cv.lm)
```

```{r second_save}
CV_errors.lm  <- CV_errors.lm %>% 
    add_row(Model.0 = cv.0, Model.1 = cv.1, Model.2 = cv.2, Model.3 = cv.3, 
           Model.4 = cv.4, Model.5 = cv.5, Model.6 = cv.6, Model.7 = cv.7)
```

For predicting the second moment, the model with the interaction term Re:Fr 
seems to have the lowest estimated test MSE according to the 10-fold cross 
validation process.

## Third Moment

```{r Third_Moment_setup}
lambda <- lambda.3
```

#### No interaction term

```{r third_no_inter}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_3 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.0 <- mean(rmse.cv.lm)
```

#### St:Re

```{r third_inter_1}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_3 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(St):log(Re), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.1 <- mean(rmse.cv.lm)
```

#### St:Fr

```{r third_inter_2}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_3 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(St):I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.2 <- mean(rmse.cv.lm)
```

#### Re:Fr

```{r third_inter_3}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_3 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.3 <- mean(rmse.cv.lm)
```

#### Re:Fr and St:Re

```{r third_inter_4}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_3 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)) + log(Re):log(St), 
                data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.4 <- mean(rmse.cv.lm)
```

#### Re:Fr and St:Fr

```{r third_inter_5}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_3 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)) + 
                    I(1 - exp(-Fr)):log(St), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.5 <- mean(rmse.cv.lm)
```

#### St:Re and St:Fr

```{r third_inter_6}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_3 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):log(St) + 
                    I(1 - exp(-Fr)):log(St), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.6 <- mean(rmse.cv.lm)
```

#### All three

```{r third_inter_7}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_3 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):log(St) + 
                    I(1 - exp(-Fr)):log(St) + log(Re):I(1 - exp(-Fr)), 
                data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.7 <- mean(rmse.cv.lm)
```

```{r third_save}
CV_errors.lm  <- CV_errors.lm %>% 
    add_row(Model.0 = cv.0, Model.1 = cv.1, Model.2 = cv.2, Model.3 = cv.3, 
           Model.4 = cv.4, Model.5 = cv.5, Model.6 = cv.6, Model.7 = cv.7)
```

For predicting the third moment, the model with the interaction term Re:Fr 
seems to have the lowest estimated test MSE according to the 10-fold cross 
validation process.

## Fourth Moment

```{r Third_Moment_setup}
lambda <- lambda.4
```

#### No interaction term

```{r fourth_no_inter}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_4 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.0 <- mean(rmse.cv.lm)
```

#### St:Re

```{r fourth_inter_1}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_4 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(St):log(Re), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.1 <- mean(rmse.cv.lm)
```

#### St:Fr

```{r fourth_inter_2}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_4 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(St):I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.2 <- mean(rmse.cv.lm)
```

#### Re:Fr

```{r fourth_inter_3}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_4 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.3 <- mean(rmse.cv.lm)
```

#### Re:Fr and St:Re

```{r fourth_inter_4}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_4 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)) + log(Re):log(St), 
                data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.4 <- mean(rmse.cv.lm)
```

#### Re:Fr and St:Fr

```{r fourth_inter_5}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_4 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):I(1 - exp(-Fr)) + 
                    I(1 - exp(-Fr)):log(St), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.5 <- mean(rmse.cv.lm)
```

#### St:Re and St:Fr

```{r fourth_inter_6}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_4 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):log(St) + 
                    I(1 - exp(-Fr)):log(St), data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.6 <- mean(rmse.cv.lm)
```

#### All three

```{r fourth_inter_7}
# Cross validation
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    lm_cv <- lm((R_moment_4 ^ lambda - 1)/lambda ~ log(St) + log(Re) + 
                    I(1 - exp(-Fr)) + log(Re):log(St) + 
                    I(1 - exp(-Fr)):log(St) + log(Re):I(1 - exp(-Fr)), 
                data = trainData)
    pred_lm <- (lambda * predict(lm_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.lm[i] = mean((pred_lm - y.test)^2)
}

cv.7 <- mean(rmse.cv.lm)
```

```{r fourth_save}
CV_errors.lm  <- CV_errors.lm %>% 
    add_row(Model.0 = cv.0, Model.1 = cv.1, Model.2 = cv.2, Model.3 = cv.3, 
           Model.4 = cv.4, Model.5 = cv.5, Model.6 = cv.6, Model.7 = cv.7)
```

For predicting the fourth moment, the model with the interaction term Re:Fr 
seems to have the lowest estimated test MSE according to the 10-fold cross 
validation process.

## GAM Models

#### First Moment

```{r First_Moment}
# setting lambda
lambda <- lambda.1
# CV set-up
shuffled_train <- train.t[sample(nrow(train.t)),] # training data
folds <- cut(seq(1,nrow(train.t)),breaks=10,labels=FALSE) # folds
rmse.cv.gam <- rep(0, 10) # error bins

# gam function with no interaction terms
gam.1.0 <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr, 
               data = train.t)
# model diagnostics
gam.check(gam.1.0)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr, 
                  data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.0 <- mean(rmse.cv.gam)

# gam function with St:Re
gam.1.1 <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re), data = train.t)
# model diagnostics
gam.check(gam.1.1)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.1 <- mean(rmse.cv.gam)

# gam function with St:Fr
gam.1.2 <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr), data = train.t)
# model diagnostics
gam.check(gam.1.2)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.2 <- mean(rmse.cv.gam)

# gam function with Re:Fr
gam.1.3 <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + Re:Fr, 
               data = train.t)
# model diagnostics
gam.check(gam.1.3)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + Re:Fr, 
                  data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.3 <- mean(rmse.cv.gam)

# gam function with St:Re, Re:Fr
gam.1.4 <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.1.4)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.4 <- mean(rmse.cv.gam)

# gam function with St:Fr, Re:Fr
gam.1.5 <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.1.5)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.5 <- mean(rmse.cv.gam)

# gam function with St:Fr, St:Re
gam.1.6 <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re+ Fr + 
                   s(St, by = Fr) + s(St, by = Re), data = train.t)
# model diagnostics
gam.check(gam.1.6)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + s(St, by = Fr), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.6 <- mean(rmse.cv.gam)

# gam function with all the interaction terms
gam.1.7 <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re+ Fr + 
                   s(St, by = Fr) + s(St, by = Re) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.1.7)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_1
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_1 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + s(St, by = Re) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.7 <- mean(rmse.cv.gam)

# save the errors
CV_errors.gam  <- tibble(Model.0 = cv.0, Model.1 = cv.1, Model.2 = cv.2, 
                     Model.3 = cv.3, Model.4 = cv.4, Model.5 = cv.5, 
                     Model.6 = cv.6, Model.7 = cv.7)
```

#### Second Moment

```{r Second_Moment}
# setting lambda
lambda <- lambda.2

# gam function with no interaction terms
gam.2.0 <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr, 
               data = train.t)
# model diagnostics
gam.check(gam.2.0)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr, 
                  data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.0 <- mean(rmse.cv.gam)

# gam function with St:Re
gam.2.1 <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re), data = train.t)
# model diagnostics
gam.check(gam.2.1)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.1 <- mean(rmse.cv.gam)

# gam function with St:Fr
gam.2.2 <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr), data = train.t)
# model diagnostics
gam.check(gam.2.2)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.2 <- mean(rmse.cv.gam)

# gam function with Re:Fr
gam.2.3 <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + Re:Fr, 
               data = train.t)
# model diagnostics
gam.check(gam.2.3)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + Re:Fr, 
                  data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.3 <- mean(rmse.cv.gam)

# gam function with St:Re, Re:Fr
gam.2.4 <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.2.4)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.4 <- mean(rmse.cv.gam)

# gam function with St:Fr, Re:Fr
gam.2.5 <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.2.5)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.5 <- mean(rmse.cv.gam)

# gam function with St:Fr, St:Re
gam.2.6 <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re+ Fr + 
                   s(St, by = Fr) + s(St, by = Re), data = train.t)
# model diagnostics
gam.check(gam.2.6)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + s(St, by = Fr), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.6 <- mean(rmse.cv.gam)

# gam function with all the interaction terms
gam.2.7 <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re+ Fr + 
                   s(St, by = Fr) + s(St, by = Re) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.2.7)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_2
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_2 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + s(St, by = Re) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.7 <- mean(rmse.cv.gam)

# save the errors
CV_errors.gam <- CV_errors.gam %>% 
    add_row(Model.0 = cv.0, Model.1 = cv.1, Model.2 = cv.2, Model.3 = cv.3, 
            Model.4 = cv.4, Model.5 = cv.5, Model.6 = cv.6, Model.7 = cv.7)
```

#### Third Moment

```{r Third_Moment}
# setting lambda
lambda <- lambda.3

# gam function with no interaction terms
gam.3.0 <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr, 
               data = train.t)
# model diagnostics
gam.check(gam.3.0)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr, 
                  data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.0 <- mean(rmse.cv.gam)

# gam function with St:Re
gam.3.1 <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re), data = train.t)
# model diagnostics
gam.check(gam.3.1)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.1 <- mean(rmse.cv.gam)

# gam function with St:Fr
gam.3.2 <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr), data = train.t)
# model diagnostics
gam.check(gam.3.2)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.2 <- mean(rmse.cv.gam)

# gam function with Re:Fr
gam.3.3 <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + Re:Fr, 
               data = train.t)
# model diagnostics
gam.check(gam.3.3)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + Re:Fr, 
                  data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.3 <- mean(rmse.cv.gam)

# gam function with St:Re, Re:Fr
gam.3.4 <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.3.4)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.4 <- mean(rmse.cv.gam)

# gam function with St:Fr, Re:Fr
gam.3.5 <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.3.5)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.5 <- mean(rmse.cv.gam)

# gam function with St:Fr, St:Re
gam.3.6 <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re+ Fr + 
                   s(St, by = Fr) + s(St, by = Re), data = train.t)
# model diagnostics
gam.check(gam.3.6)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + s(St, by = Fr), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.6 <- mean(rmse.cv.gam)

# gam function with all the interaction terms
gam.3.7 <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re+ Fr + 
                   s(St, by = Fr) + s(St, by = Re) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.3.7)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_3
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_3 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + s(St, by = Re) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.7 <- mean(rmse.cv.gam)

# save the errors
CV_errors.gam <- CV_errors.gam %>% 
    add_row(Model.0 = cv.0, Model.1 = cv.1, Model.2 = cv.2, Model.3 = cv.3, 
            Model.4 = cv.4, Model.5 = cv.5, Model.6 = cv.6, Model.7 = cv.7)
```

#### Fourth Moment

```{r Fourth_Moment}
# setting lambda
lambda <- lambda.4

# gam function with no interaction terms
gam.4.0 <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr, 
               data = train.t)
# model diagnostics
gam.check(gam.4.0)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr, 
                  data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.0 <- mean(rmse.cv.gam)

# gam function with St:Re
gam.4.1 <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re), data = train.t)
# model diagnostics
gam.check(gam.4.1)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.1 <- mean(rmse.cv.gam)

# gam function with St:Fr
gam.4.2 <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr), data = train.t)
# model diagnostics
gam.check(gam.4.2)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.2 <- mean(rmse.cv.gam)

# gam function with Re:Fr
gam.4.3 <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + Re:Fr, 
               data = train.t)
# model diagnostics
gam.check(gam.4.3)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + Re:Fr, 
                  data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.3 <- mean(rmse.cv.gam)

# gam function with St:Re, Re:Fr
gam.4.4 <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.4.4)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.4 <- mean(rmse.cv.gam)

# gam function with St:Fr, Re:Fr
gam.4.5 <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.4.5)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Fr) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.5 <- mean(rmse.cv.gam)

# gam function with St:Fr, St:Re
gam.4.6 <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re+ Fr + 
                   s(St, by = Fr) + s(St, by = Re), data = train.t)
# model diagnostics
gam.check(gam.4.6)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + s(St, by = Fr), data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.6 <- mean(rmse.cv.gam)

# gam function with all the interaction terms
gam.4.7 <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re+ Fr + 
                   s(St, by = Fr) + s(St, by = Re) + Re:Fr, data = train.t)
# model diagnostics
gam.check(gam.4.7)
# 10-fold CV test error est
for(i in 1:10){
    #Segment your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- shuffled_train[testIndexes, ]
    y.test <- testData$R_moment_4
    trainData <- shuffled_train[-testIndexes, ]
   
    #Use the test and train data
    gam_cv <- gam((R_moment_4 ^ lambda - 1)/lambda ~ s(St) + Re + Fr + 
                   s(St, by = Re) + s(St, by = Re) + Re:Fr, data = trainData)
    pred_gam <- (lambda * predict(gam_cv, testData, type='response') + 1)^(1/lambda)
    rmse.cv.gam[i] = mean((pred_gam - y.test)^2)
}

cv.7 <- mean(rmse.cv.gam)

# save the errors
CV_errors.gam <- CV_errors.gam %>% 
    add_row(Model.0 = cv.0, Model.1 = cv.1, Model.2 = cv.2, Model.3 = cv.3, 
            Model.4 = cv.4, Model.5 = cv.5, Model.6 = cv.6, Model.7 = cv.7)
```

```{r gam_funcs}
# getting the list of gam functions with the least CV-error for each moment
apply(CV_errors.gam, 1, FUN = which.min)

best.gam <- list(gam.1.5, gam.2.5, gam.3.5, gam.4.5)
```